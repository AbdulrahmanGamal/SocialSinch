package com.social.backendless;

import android.content.Context;
import android.util.Log;

import com.backendless.Backendless;
import com.backendless.Subscription;
import com.backendless.async.callback.AsyncCallback;
import com.backendless.exceptions.BackendlessFault;
import com.backendless.messaging.Message;
import com.backendless.messaging.PublishOptions;
import com.backendless.messaging.SubscriptionOptions;
import com.backendless.services.messaging.MessageStatus;
import com.social.backendless.bus.RxOutgoingMessageBus;
import com.social.backendless.database.ChatBriteDataSource;
import com.social.backendless.model.ChatMessage;
import com.social.backendless.model.ChatStatus;
import com.google.gson.Gson;

import java.util.Calendar;
import java.util.List;
import java.util.Locale;

import rx.Emitter;
import rx.Observable;
import rx.functions.Action1;
import rx.functions.Func1;

/**
 * Singleton to handle the subscription to the channel and the publishing
 */
public class PublishSubscribeHandler {

    private static final String TAG = "PublishSubscribeHandler";
    private static final String DEFAULT_CHANNEL = "default";
    private Subscription mSubscription;
    private static PublishSubscribeHandler sPublishSubscriberHandler;
    private ChatBriteDataSource mDataSource;
    private RxOutgoingMessageBus mMessageBus = RxOutgoingMessageBus.getInstance();

    public static PublishSubscribeHandler getInstance(Context context) {
        if (sPublishSubscriberHandler == null) {
           sPublishSubscriberHandler = new PublishSubscribeHandler(context);
        }
        return sPublishSubscriberHandler;
    }

    private PublishSubscribeHandler(Context context) {
        this.mDataSource = ChatBriteDataSource.getInstance(context);
    }

    /**
     * Creates an emitter observable to listen message from the default channel
     */
    public void attachToChannel() {
        SubscriptionOptions subscriptionOptions = new SubscriptionOptions();
        subscriptionOptions.setSubscriberId(Backendless.UserService.loggedInUser());
        subscriptionOptions.setSelector( "recipient='" + Backendless.UserService.loggedInUser() + "'");
        Backendless.Messaging.subscribe(DEFAULT_CHANNEL,
                new AsyncCallback<List<Message>>() {
                    @Override
                    public void handleResponse( List<Message> response ) {
                        processIncomingMessage(response);
                    }
                    @Override
                    public void handleFault( BackendlessFault fault ) {
                        Log.e(TAG, "Fault Receiving message : " + fault);
                    }
                }, subscriptionOptions ,
                new AsyncCallback<Subscription>() {
                    @Override
                    public void handleResponse( Subscription response )
                    {
                        mSubscription = response;
                    }
                    @Override
                    public void handleFault( BackendlessFault fault )
                    {
                        Log.e(TAG, "Subscription fault : " + fault);
                    }
                }
        );
    }

    /**
     * Send a message generated by the user
     * @param recipientUserId
     * @param textBody
     */
    public void sendPrivateMessage(String recipientUserId, String textBody) {
        processOutgoingMessage(recipientUserId, textBody, null, ChatStatus.SEND);
    }
    /**
     * Sends an instant message to the default channel
     * @param recipientUserId
     * @param textBody
     */
    public void processOutgoingMessage(String recipientUserId,
                                       String textBody,
                                       String sentId,
                                       ChatStatus status) {
        final ChatMessage chatMessageInfo = generateChatMessage(recipientUserId, textBody, status);
        chatMessageInfo.setSentId(sentId);

        Gson gson = new Gson();
        String jsonMessage = gson.toJson(chatMessageInfo);

        getPublisher(jsonMessage, recipientUserId).filter(new Func1<Object, Boolean>() {
            @Override
            public Boolean call(Object result) {
                //skip the notification received for DELIVERED messages
                return  result instanceof MessageStatus &&
                        !chatMessageInfo.getStatus().equals(ChatStatus.DELIVERED);
            }
        }).subscribe(new Action1<Object>() {
            @Override
            public void call(Object result) {
                if (result instanceof MessageStatus) {
                    Log.e(TAG, "Message was published " + result);
                    notifyViews(chatMessageInfo, ChatStatus.SENT);
                } else {
                    Log.e(TAG, "Message was not published: " + result);
                    notifyViews(chatMessageInfo, ChatStatus.FAILED);
                }
            }
        });
    }

    /**
     * Notify the views about the event using the rx bus
     * @param message
     */
    public synchronized void notifyViews(ChatMessage message, ChatStatus status) {
        switch (status) {
            case SENT:
            case FAILED:
                mDataSource.updateMessageStatus(message.getMessageId(), status);
                break;
            case RECEIVED:
                message.setStatus(ChatStatus.RECEIVED);
                Long messageId = mDataSource.addNewMessage(message);
                message.setMessageId(messageId);
                break;
            case DELIVERED:
                //change the status in DB to flag the previous SENT now to DELIVERED
                mDataSource.updateMessageStatus(Long.valueOf(message.getSentId()), status);
                break;
        }
        if (mMessageBus.hasObservers()) {
            message.setStatus(status);
            mMessageBus.setMessage(message);
        }
    }

    /**
     * Process the receive message and execute the according action depending of the status
     * @param response
     */
    private void processIncomingMessage(List<Message> response) {
        final Gson gson = new Gson();
        for (Message message : response) {
            Log.e(TAG, "Received message : " + message);
            ChatMessage messageReceived = gson.fromJson((String)message.getData(), ChatMessage.class);
            switch (messageReceived.getStatus()) {
                case SEND:
                    notifyViews(messageReceived, ChatStatus.RECEIVED);
                    //use the sentId filed to notify the other user that the message id
                    //was received correctly
                    processOutgoingMessage(messageReceived.getSenderId(), "",
                                           String.valueOf(messageReceived.getMessageId()),
                                           ChatStatus.DELIVERED);
                    break;
                case DELIVERED:
                    notifyViews(messageReceived, ChatStatus.DELIVERED);
                    break;
                //TODO consider the other type of cases
                default:
                    break;

            }
        }
    }
    /**
     * Wrap the information into a ChatMessage object
     * @param recipientUserId
     * @param textBody
     * @return
     */
    private ChatMessage generateChatMessage(String recipientUserId, String textBody,  ChatStatus status) {
        final ChatMessage chatMessageInfo = new ChatMessage();
        String senderId = Backendless.UserService.loggedInUser();
        chatMessageInfo.setRecipientIds(recipientUserId);
        chatMessageInfo.setSenderId(senderId);
        chatMessageInfo.setTextBody(textBody);
        chatMessageInfo.setTimestamp(Calendar.getInstance(Locale.getDefault()).getTime());
        chatMessageInfo.setStatus(status);

        if (status.equals(ChatStatus.SEND)) {
            //before sending the message, save it in Db to keep track of the message id from now on
            final long messageId = mDataSource.addNewMessage(chatMessageInfo);
            chatMessageInfo.setMessageId(messageId);
        }

        return chatMessageInfo;
    }


    /**
     * Observable that publishes the messages
     * @return
     */
    private Observable<Object> getPublisher(final String jsonMessage, final String recipientUserId) {
        return Observable.fromEmitter(new Action1<Emitter<Object>>() {
            @Override
            public void call(final Emitter<Object> emitter) {
                PublishOptions publishOptions = new PublishOptions();
                publishOptions.setPublisherId(Backendless.UserService.loggedInUser());
                publishOptions.putHeader("recipient", recipientUserId);
                Backendless.Messaging.publish(DEFAULT_CHANNEL, jsonMessage, publishOptions, new AsyncCallback<MessageStatus>() {
                    @Override
                    public void handleResponse(MessageStatus messageStatus) {
                        emitter.onNext(messageStatus);
                    }

                    @Override
                    public void handleFault(BackendlessFault backendlessFault) {
                        emitter.onNext(backendlessFault);
                    }
                });
            }
        }, Emitter.BackpressureMode.NONE);
    }

    public long getTotalMessages(String identifier) {
        return mDataSource.getTotalMessage(identifier);
    }

    public void resumeSubscription() {
        if (mSubscription != null) {
            mSubscription.resumeSubscription();
        }
    }

    public void pauseSubscription() {
        if (mSubscription != null) {
            mSubscription.pauseSubscription();
        }
    }

    public void cancelSubscription() {
        if (mSubscription != null) {
            mSubscription.cancelSubscription();
        }
    }

    public List<ChatMessage> retrieveLastMessages(String senderId, String recipientId, int i) {
        return mDataSource.retrieveLastMessages(senderId, recipientId, i);
    }
}
